/*
 * User Service
 *
 * This API is intended to manage users in a ZITADEL instance.
 *
 * OpenAPI spec version: 2.0
 * Contact: hi@zitadel.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::{Deserialize, Serialize};

use crate::v2::users::models;

#[derive(Debug, Serialize, Deserialize)]
pub struct AddHumanUserRequest {
	/// optionally set your own id unique for the user.
	#[serde(rename = "userId")]
	user_id: Option<String>,
	/// optionally set a unique username, if none is provided the email will be
	/// used.
	#[serde(rename = "username")]
	username: Option<String>,
	#[serde(rename = "organization")]
	organization: Option<models::Organization>,
	#[serde(rename = "profile")]
	profile: models::SetHumanProfile,
	#[serde(rename = "email")]
	email: models::SetHumanEmail,
	#[serde(rename = "phone")]
	phone: Option<models::SetHumanPhone>,
	#[serde(rename = "metadata")]
	metadata: Option<Vec<models::SetMetadataEntry>>,
	#[serde(rename = "password")]
	password: Option<models::Password>,
	#[serde(rename = "hashedPassword")]
	hashed_password: Option<models::HashedPassword>,
	#[serde(rename = "idpLinks")]
	idp_links: Option<Vec<models::IdpLink>>,
	/// An Implementation of RFC 6238 is used, with HMAC-SHA-1 and time-step of
	/// 30 seconds. Currently no other options are supported, and if anything
	/// different is used the validation will fail.
	#[serde(rename = "totpSecret")]
	totp_secret: Option<String>,
}

impl AddHumanUserRequest {
	pub fn new(
		profile: models::SetHumanProfile,
		email: models::SetHumanEmail,
	) -> AddHumanUserRequest {
		AddHumanUserRequest {
			user_id: None,
			username: None,
			organization: None,
			profile,
			email,
			phone: None,
			metadata: None,
			password: None,
			hashed_password: None,
			idp_links: None,
			totp_secret: None,
		}
	}

	pub fn set_user_id(&mut self, user_id: String) {
		self.user_id = Some(user_id);
	}

	pub fn with_user_id(mut self, user_id: String) -> AddHumanUserRequest {
		self.user_id = Some(user_id);
		self
	}

	pub fn user_id(&self) -> Option<&String> {
		self.user_id.as_ref()
	}

	pub fn reset_user_id(&mut self) {
		self.user_id = None;
	}

	pub fn set_username(&mut self, username: String) {
		self.username = Some(username);
	}

	pub fn with_username(mut self, username: String) -> AddHumanUserRequest {
		self.username = Some(username);
		self
	}

	pub fn username(&self) -> Option<&String> {
		self.username.as_ref()
	}

	pub fn reset_username(&mut self) {
		self.username = None;
	}

	pub fn set_organization(&mut self, organization: models::Organization) {
		self.organization = Some(organization);
	}

	pub fn with_organization(mut self, organization: models::Organization) -> AddHumanUserRequest {
		self.organization = Some(organization);
		self
	}

	pub fn organization(&self) -> Option<&models::Organization> {
		self.organization.as_ref()
	}

	pub fn reset_organization(&mut self) {
		self.organization = None;
	}

	pub fn set_profile(&mut self, profile: models::SetHumanProfile) {
		self.profile = profile;
	}

	pub fn with_profile(mut self, profile: models::SetHumanProfile) -> AddHumanUserRequest {
		self.profile = profile;
		self
	}

	pub fn profile(&self) -> &models::SetHumanProfile {
		&self.profile
	}

	pub fn set_email(&mut self, email: models::SetHumanEmail) {
		self.email = email;
	}

	pub fn with_email(mut self, email: models::SetHumanEmail) -> AddHumanUserRequest {
		self.email = email;
		self
	}

	pub fn email(&self) -> &models::SetHumanEmail {
		&self.email
	}

	pub fn set_phone(&mut self, phone: models::SetHumanPhone) {
		self.phone = Some(phone);
	}

	pub fn with_phone(mut self, phone: models::SetHumanPhone) -> AddHumanUserRequest {
		self.phone = Some(phone);
		self
	}

	pub fn phone(&self) -> Option<&models::SetHumanPhone> {
		self.phone.as_ref()
	}

	pub fn reset_phone(&mut self) {
		self.phone = None;
	}

	pub fn set_metadata(&mut self, metadata: Vec<models::SetMetadataEntry>) {
		self.metadata = Some(metadata);
	}

	pub fn with_metadata(mut self, metadata: Vec<models::SetMetadataEntry>) -> AddHumanUserRequest {
		self.metadata = Some(metadata);
		self
	}

	pub fn metadata(&self) -> Option<&Vec<models::SetMetadataEntry>> {
		self.metadata.as_ref()
	}

	pub fn reset_metadata(&mut self) {
		self.metadata = None;
	}

	pub fn set_password(&mut self, password: models::Password) {
		self.password = Some(password);
	}

	pub fn with_password(mut self, password: models::Password) -> AddHumanUserRequest {
		self.password = Some(password);
		self
	}

	pub fn password(&self) -> Option<&models::Password> {
		self.password.as_ref()
	}

	pub fn reset_password(&mut self) {
		self.password = None;
	}

	pub fn set_hashed_password(&mut self, hashed_password: models::HashedPassword) {
		self.hashed_password = Some(hashed_password);
	}

	pub fn with_hashed_password(
		mut self,
		hashed_password: models::HashedPassword,
	) -> AddHumanUserRequest {
		self.hashed_password = Some(hashed_password);
		self
	}

	pub fn hashed_password(&self) -> Option<&models::HashedPassword> {
		self.hashed_password.as_ref()
	}

	pub fn reset_hashed_password(&mut self) {
		self.hashed_password = None;
	}

	pub fn set_idp_links(&mut self, idp_links: Vec<models::IdpLink>) {
		self.idp_links = Some(idp_links);
	}

	pub fn with_idp_links(mut self, idp_links: Vec<models::IdpLink>) -> AddHumanUserRequest {
		self.idp_links = Some(idp_links);
		self
	}

	pub fn idp_links(&self) -> Option<&Vec<models::IdpLink>> {
		self.idp_links.as_ref()
	}

	pub fn reset_idp_links(&mut self) {
		self.idp_links = None;
	}

	pub fn set_totp_secret(&mut self, totp_secret: String) {
		self.totp_secret = Some(totp_secret);
	}

	pub fn with_totp_secret(mut self, totp_secret: String) -> AddHumanUserRequest {
		self.totp_secret = Some(totp_secret);
		self
	}

	pub fn totp_secret(&self) -> Option<&String> {
		self.totp_secret.as_ref()
	}

	pub fn reset_totp_secret(&mut self) {
		self.totp_secret = None;
	}
}
