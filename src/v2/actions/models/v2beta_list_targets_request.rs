// SPDX-FileCopyrightText: 2025 Famedly GmbH (info@famedly.com)
//
// SPDX-License-Identifier: Apache-2.0

/*
 * Action Service
 *
 * This API is intended to manage custom executions (previously known as
 * actions) in a ZITADEL instance. This service is in beta state. It can AND
 * will continue breaking until a stable version is released.
 *
 * OpenAPI spec version: 2.0-beta
 * Contact: hi@zitadel.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct V2betaListTargetsRequest {
	/// List limitations and ordering.
	#[serde(rename = "pagination")]
	#[serde(skip_serializing_if = "Option::is_none")]
	pagination: Option<super::V2betaPaginationRequest>,
	/// The field the result is sorted by. The default is the creation date.
	/// Beware that if you change this, your result pagination might be
	/// inconsistent.
	#[serde(rename = "sortingColumn")]
	#[serde(skip_serializing_if = "Option::is_none")]
	sorting_column: Option<super::V2betaTargetFieldName>,
	/// Define the criteria to query for.
	#[serde(rename = "filters")]
	#[serde(skip_serializing_if = "Option::is_none")]
	filters: Option<Vec<super::V2betaTargetSearchFilter>>,
}

impl V2betaListTargetsRequest {
	pub fn new() -> V2betaListTargetsRequest {
		V2betaListTargetsRequest { pagination: None, sorting_column: None, filters: None }
	}

	pub fn set_pagination(&mut self, pagination: super::V2betaPaginationRequest) {
		self.pagination = Some(pagination);
	}

	pub fn with_pagination(
		mut self,
		pagination: super::V2betaPaginationRequest,
	) -> V2betaListTargetsRequest {
		self.pagination = Some(pagination);
		self
	}

	pub fn pagination(&self) -> Option<&super::V2betaPaginationRequest> {
		self.pagination.as_ref()
	}

	pub fn reset_pagination(&mut self) {
		self.pagination = None;
	}

	pub fn set_sorting_column(&mut self, sorting_column: super::V2betaTargetFieldName) {
		self.sorting_column = Some(sorting_column);
	}

	pub fn with_sorting_column(
		mut self,
		sorting_column: super::V2betaTargetFieldName,
	) -> V2betaListTargetsRequest {
		self.sorting_column = Some(sorting_column);
		self
	}

	pub fn sorting_column(&self) -> Option<&super::V2betaTargetFieldName> {
		self.sorting_column.as_ref()
	}

	pub fn reset_sorting_column(&mut self) {
		self.sorting_column = None;
	}

	pub fn set_filters(&mut self, filters: Vec<super::V2betaTargetSearchFilter>) {
		self.filters = Some(filters);
	}

	pub fn with_filters(
		mut self,
		filters: Vec<super::V2betaTargetSearchFilter>,
	) -> V2betaListTargetsRequest {
		self.filters = Some(filters);
		self
	}

	pub fn filters(&self) -> Option<&Vec<super::V2betaTargetSearchFilter>> {
		self.filters.as_ref()
	}

	pub fn reset_filters(&mut self) {
		self.filters = None;
	}
}

use crate::v2::pagination::{PaginationParams, PaginationRequest};

impl PaginationRequest<V2betaListTargetsRequest>
	for (
		Option<PaginationParams>,
		Option<super::V2betaTargetFieldName>,
		Option<Vec<super::V2betaTargetSearchFilter>>,
	)
{
	#[allow(clippy::cast_possible_wrap)]
	fn to_paginated_request(&self, page: usize) -> V2betaListTargetsRequest {
		let params = self.0.as_ref().unwrap_or(&PaginationParams::DEFAULT);
		let pagination = Some(
			super::V2betaPaginationRequest::new()
				.with_limit(params.page_size as i64)
				.with_offset((page * params.page_size).to_string())
				.with_asc(params.asc),
		);

		V2betaListTargetsRequest {
			pagination,
			sorting_column: self.1.clone(),
			filters: self.2.clone(),
		}
	}

	fn page_size(&self) -> usize {
		self.0.as_ref().unwrap_or(&PaginationParams::DEFAULT).page_size
	}
}
