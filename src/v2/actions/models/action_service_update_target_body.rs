// SPDX-FileCopyrightText: 2025 Famedly GmbH (info@famedly.com)
//
// SPDX-License-Identifier: Apache-2.0

/*
 * Action Service
 *
 * This API is intended to manage custom executions (previously known as
 * actions) in a ZITADEL instance. This service is in beta state. It can AND
 * will continue breaking until a stable version is released.
 *
 * OpenAPI spec version: 2.0-beta
 * Contact: hi@zitadel.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActionServiceUpdateTargetBody {
	#[serde(rename = "name")]
	name: Option<String>,
	/// Wait for response but response body is ignored, status is checked, call
	/// is sent as post.
	#[serde(rename = "restWebhook")]
	rest_webhook: Option<super::V2betaRestWebhook>,
	/// Wait for response and response body is used, status is checked, call is
	/// sent as post.
	#[serde(rename = "restCall")]
	rest_call: Option<super::V2betaRestCall>,
	/// Call is executed in parallel to others, ZITADEL does not wait until the
	/// call is finished. The state is ignored, call is sent as post.
	#[serde(rename = "restAsync")]
	rest_async: Option<super::V2betaRestAsync>,
	/// Timeout defines the duration until ZITADEL cancels the execution. If the
	/// target doesn't respond before this timeout expires, then the connection
	/// is closed and the action fails. Depending on the target type and
	/// possible setting on `interrupt_on_error` following targets will not be
	/// called. In case of a `rest_async` target only this specific target will
	/// fail, without any influence on other targets of the same execution.
	#[serde(rename = "timeout")]
	timeout: Option<String>,
	#[serde(rename = "endpoint")]
	endpoint: Option<String>,
	/// Regenerate the key used for signing and checking the payload sent to the
	/// target. Set the graceful period for the existing key. During that time,
	/// the previous signing key and the new one will be used to sign the
	/// request to allow you a smooth transition onf your API.  Note that we
	/// currently only allow an immediate rotation (\"0s\") and will support
	/// longer expirations in the future.
	#[serde(rename = "expirationSigningKey")]
	expiration_signing_key: Option<String>,
}

impl ActionServiceUpdateTargetBody {
	pub fn new() -> ActionServiceUpdateTargetBody {
		ActionServiceUpdateTargetBody {
			name: None,
			rest_webhook: None,
			rest_call: None,
			rest_async: None,
			timeout: None,
			endpoint: None,
			expiration_signing_key: None,
		}
	}

	pub fn set_name(&mut self, name: String) {
		self.name = Some(name);
	}

	pub fn with_name(mut self, name: String) -> ActionServiceUpdateTargetBody {
		self.name = Some(name);
		self
	}

	pub fn name(&self) -> Option<&String> {
		self.name.as_ref()
	}

	pub fn reset_name(&mut self) {
		self.name = None;
	}

	pub fn set_rest_webhook(&mut self, rest_webhook: super::V2betaRestWebhook) {
		self.rest_webhook = Some(rest_webhook);
	}

	pub fn with_rest_webhook(
		mut self,
		rest_webhook: super::V2betaRestWebhook,
	) -> ActionServiceUpdateTargetBody {
		self.rest_webhook = Some(rest_webhook);
		self
	}

	pub fn rest_webhook(&self) -> Option<&super::V2betaRestWebhook> {
		self.rest_webhook.as_ref()
	}

	pub fn reset_rest_webhook(&mut self) {
		self.rest_webhook = None;
	}

	pub fn set_rest_call(&mut self, rest_call: super::V2betaRestCall) {
		self.rest_call = Some(rest_call);
	}

	pub fn with_rest_call(
		mut self,
		rest_call: super::V2betaRestCall,
	) -> ActionServiceUpdateTargetBody {
		self.rest_call = Some(rest_call);
		self
	}

	pub fn rest_call(&self) -> Option<&super::V2betaRestCall> {
		self.rest_call.as_ref()
	}

	pub fn reset_rest_call(&mut self) {
		self.rest_call = None;
	}

	pub fn set_rest_async(&mut self, rest_async: super::V2betaRestAsync) {
		self.rest_async = Some(rest_async);
	}

	pub fn with_rest_async(
		mut self,
		rest_async: super::V2betaRestAsync,
	) -> ActionServiceUpdateTargetBody {
		self.rest_async = Some(rest_async);
		self
	}

	pub fn rest_async(&self) -> Option<&super::V2betaRestAsync> {
		self.rest_async.as_ref()
	}

	pub fn reset_rest_async(&mut self) {
		self.rest_async = None;
	}

	pub fn set_timeout(&mut self, timeout: String) {
		self.timeout = Some(timeout);
	}

	pub fn with_timeout(mut self, timeout: String) -> ActionServiceUpdateTargetBody {
		self.timeout = Some(timeout);
		self
	}

	pub fn timeout(&self) -> Option<&String> {
		self.timeout.as_ref()
	}

	pub fn reset_timeout(&mut self) {
		self.timeout = None;
	}

	pub fn set_endpoint(&mut self, endpoint: String) {
		self.endpoint = Some(endpoint);
	}

	pub fn with_endpoint(mut self, endpoint: String) -> ActionServiceUpdateTargetBody {
		self.endpoint = Some(endpoint);
		self
	}

	pub fn endpoint(&self) -> Option<&String> {
		self.endpoint.as_ref()
	}

	pub fn reset_endpoint(&mut self) {
		self.endpoint = None;
	}

	pub fn set_expiration_signing_key(&mut self, expiration_signing_key: String) {
		self.expiration_signing_key = Some(expiration_signing_key);
	}

	pub fn with_expiration_signing_key(
		mut self,
		expiration_signing_key: String,
	) -> ActionServiceUpdateTargetBody {
		self.expiration_signing_key = Some(expiration_signing_key);
		self
	}

	pub fn expiration_signing_key(&self) -> Option<&String> {
		self.expiration_signing_key.as_ref()
	}

	pub fn reset_expiration_signing_key(&mut self) {
		self.expiration_signing_key = None;
	}
}
