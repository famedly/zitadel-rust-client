/* 
 * Management API
 *
 * The management API is as the name states the interface where systems can mutate IAM objects like organizations, projects, clients, users and so on if they have the necessary access rights.
 *
 * OpenAPI spec version: 1.0
 * Contact: hi@zitadel.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// V1ChangeQuery : Filter possibility for the changes/history of an Object.

#[allow(unused_imports)]
use serde_json::Value;
use crate::v2::management::models;
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct V1ChangeQuery {
  /// sequence represents the order of events. It's always counting
  #[serde(rename = "sequence")]
  sequence: Option<String>,
  /// Maximum amount of events returned. The default is set to 1000 in https://github.com/zitadel/zitadel/blob/new-eventstore/cmd/zitadel/startup.yaml. If no limit is set or the limit exceeds the maximum configured ZITADEL will throw an error. If no limit is present the default is taken.
  #[serde(rename = "limit")]
  limit: Option<i64>,
  /// default is descending
  #[serde(rename = "asc")]
  asc: Option<bool>
}

impl V1ChangeQuery {
  /// Filter possibility for the changes/history of an Object.
  pub fn new() -> V1ChangeQuery {
    V1ChangeQuery {
      sequence: None,
      limit: None,
      asc: None
    }
  }

  pub fn set_sequence(&mut self, sequence: String) {
    self.sequence = Some(sequence);
  }

  pub fn with_sequence(mut self, sequence: String) -> V1ChangeQuery {
    self.sequence = Some(sequence);
    self
  }

  pub fn sequence(&self) -> Option<&String> {
    self.sequence.as_ref()
  }

  pub fn reset_sequence(&mut self) {
    self.sequence = None;
  }

  pub fn set_limit(&mut self, limit: i64) {
    self.limit = Some(limit);
  }

  pub fn with_limit(mut self, limit: i64) -> V1ChangeQuery {
    self.limit = Some(limit);
    self
  }

  pub fn limit(&self) -> Option<&i64> {
    self.limit.as_ref()
  }

  pub fn reset_limit(&mut self) {
    self.limit = None;
  }

  pub fn set_asc(&mut self, asc: bool) {
    self.asc = Some(asc);
  }

  pub fn with_asc(mut self, asc: bool) -> V1ChangeQuery {
    self.asc = Some(asc);
    self
  }

  pub fn asc(&self) -> Option<&bool> {
    self.asc.as_ref()
  }

  pub fn reset_asc(&mut self) {
    self.asc = None;
  }

}



