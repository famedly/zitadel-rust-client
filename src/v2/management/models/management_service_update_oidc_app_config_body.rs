/*
 * Management API
 *
 * The management API is as the name states the interface where systems can
 * mutate IAM objects like organizations, projects, clients, users and so on
 * if they have the necessary access rights.
 *
 * OpenAPI spec version: 1.0
 * Contact: hi@zitadel.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use serde_json::Value;

use crate::v2::management::models;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ManagementServiceUpdateOidcAppConfigBody {
	/// Callback URI of the authorization request where the code or tokens will
	/// be sent to
	#[serde(rename = "redirectUris")]
	redirect_uris: Option<Vec<String>>,
	/// Determines whether a code, id_token token or just id_token will be
	/// returned
	#[serde(rename = "responseTypes")]
	response_types: Option<Vec<models::V1OidcResponseType>>,
	/// The flow type the application uses to gain access
	#[serde(rename = "grantTypes")]
	grant_types: Option<Vec<models::V1OidcGrantType>>,
	/// Determines the paradigm of the application
	#[serde(rename = "appType")]
	app_type: Option<models::V1OidcAppType>,
	/// Defines how the application passes login credentials
	#[serde(rename = "authMethodType")]
	auth_method_type: Option<models::V1OidcAuthMethodType>,
	/// ZITADEL will redirect to this link after a successful logout
	#[serde(rename = "postLogoutRedirectUris")]
	post_logout_redirect_uris: Option<Vec<String>>,
	/// Used for development, some checks of the OIDC specification will not be
	/// checked.
	#[serde(rename = "devMode")]
	dev_mode: Option<bool>,
	/// Type of the access token returned from ZITADEL
	#[serde(rename = "accessTokenType")]
	access_token_type: Option<models::V1OidcTokenType>,
	/// Adds roles to the claims of the access token (only if type == JWT) even
	/// if they are not requested by scopes
	#[serde(rename = "accessTokenRoleAssertion")]
	access_token_role_assertion: Option<bool>,
	/// Adds roles to the claims of the id token even if they are not requested
	/// by scopes
	#[serde(rename = "idTokenRoleAssertion")]
	id_token_role_assertion: Option<bool>,
	/// Claims of profile, email, address and phone scopes are added to the id
	/// token even if an access token is issued. Attention this violates the
	/// OIDC specification
	#[serde(rename = "idTokenUserinfoAssertion")]
	id_token_userinfo_assertion: Option<bool>,
	/// Used to compensate time difference of servers. Duration added to the
	/// \"exp\" claim and subtracted from \"iat\", \"auth_time\" and \"nbf\"
	/// claims
	#[serde(rename = "clockSkew")]
	clock_skew: Option<String>,
	/// Additional origins (other than the redirect_uris) from where the API can
	/// be used, provided string has to be an origin (scheme://hostname[:port])
	/// without path, query or fragment
	#[serde(rename = "additionalOrigins")]
	additional_origins: Option<Vec<String>>,
	/// Skip the successful login page on native apps and directly redirect the
	/// user to the callback.
	#[serde(rename = "skipNativeAppSuccessPage")]
	skip_native_app_success_page: Option<bool>,
	/// ZITADEL will use this URI to notify the application about terminated session according to the OIDC Back-Channel Logout (https://openid.net/specs/openid-connect-backchannel-1_0.html)
	#[serde(rename = "backChannelLogoutUri")]
	back_channel_logout_uri: Option<String>,
	/// Specify the preferred login UI, where the user is redirected to for
	/// authentication. If unset, the login UI is chosen by the instance
	/// default.
	#[serde(rename = "loginVersion")]
	login_version: Option<models::V1LoginVersion>,
}

impl ManagementServiceUpdateOidcAppConfigBody {
	pub fn new() -> ManagementServiceUpdateOidcAppConfigBody {
		ManagementServiceUpdateOidcAppConfigBody {
			redirect_uris: None,
			response_types: None,
			grant_types: None,
			app_type: None,
			auth_method_type: None,
			post_logout_redirect_uris: None,
			dev_mode: None,
			access_token_type: None,
			access_token_role_assertion: None,
			id_token_role_assertion: None,
			id_token_userinfo_assertion: None,
			clock_skew: None,
			additional_origins: None,
			skip_native_app_success_page: None,
			back_channel_logout_uri: None,
			login_version: None,
		}
	}

	pub fn set_redirect_uris(&mut self, redirect_uris: Vec<String>) {
		self.redirect_uris = Some(redirect_uris);
	}

	pub fn with_redirect_uris(
		mut self,
		redirect_uris: Vec<String>,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.redirect_uris = Some(redirect_uris);
		self
	}

	pub fn redirect_uris(&self) -> Option<&Vec<String>> {
		self.redirect_uris.as_ref()
	}

	pub fn reset_redirect_uris(&mut self) {
		self.redirect_uris = None;
	}

	pub fn set_response_types(&mut self, response_types: Vec<models::V1OidcResponseType>) {
		self.response_types = Some(response_types);
	}

	pub fn with_response_types(
		mut self,
		response_types: Vec<models::V1OidcResponseType>,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.response_types = Some(response_types);
		self
	}

	pub fn response_types(&self) -> Option<&Vec<models::V1OidcResponseType>> {
		self.response_types.as_ref()
	}

	pub fn reset_response_types(&mut self) {
		self.response_types = None;
	}

	pub fn set_grant_types(&mut self, grant_types: Vec<models::V1OidcGrantType>) {
		self.grant_types = Some(grant_types);
	}

	pub fn with_grant_types(
		mut self,
		grant_types: Vec<models::V1OidcGrantType>,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.grant_types = Some(grant_types);
		self
	}

	pub fn grant_types(&self) -> Option<&Vec<models::V1OidcGrantType>> {
		self.grant_types.as_ref()
	}

	pub fn reset_grant_types(&mut self) {
		self.grant_types = None;
	}

	pub fn set_app_type(&mut self, app_type: models::V1OidcAppType) {
		self.app_type = Some(app_type);
	}

	pub fn with_app_type(
		mut self,
		app_type: models::V1OidcAppType,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.app_type = Some(app_type);
		self
	}

	pub fn app_type(&self) -> Option<&models::V1OidcAppType> {
		self.app_type.as_ref()
	}

	pub fn reset_app_type(&mut self) {
		self.app_type = None;
	}

	pub fn set_auth_method_type(&mut self, auth_method_type: models::V1OidcAuthMethodType) {
		self.auth_method_type = Some(auth_method_type);
	}

	pub fn with_auth_method_type(
		mut self,
		auth_method_type: models::V1OidcAuthMethodType,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.auth_method_type = Some(auth_method_type);
		self
	}

	pub fn auth_method_type(&self) -> Option<&models::V1OidcAuthMethodType> {
		self.auth_method_type.as_ref()
	}

	pub fn reset_auth_method_type(&mut self) {
		self.auth_method_type = None;
	}

	pub fn set_post_logout_redirect_uris(&mut self, post_logout_redirect_uris: Vec<String>) {
		self.post_logout_redirect_uris = Some(post_logout_redirect_uris);
	}

	pub fn with_post_logout_redirect_uris(
		mut self,
		post_logout_redirect_uris: Vec<String>,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.post_logout_redirect_uris = Some(post_logout_redirect_uris);
		self
	}

	pub fn post_logout_redirect_uris(&self) -> Option<&Vec<String>> {
		self.post_logout_redirect_uris.as_ref()
	}

	pub fn reset_post_logout_redirect_uris(&mut self) {
		self.post_logout_redirect_uris = None;
	}

	pub fn set_dev_mode(&mut self, dev_mode: bool) {
		self.dev_mode = Some(dev_mode);
	}

	pub fn with_dev_mode(mut self, dev_mode: bool) -> ManagementServiceUpdateOidcAppConfigBody {
		self.dev_mode = Some(dev_mode);
		self
	}

	pub fn dev_mode(&self) -> Option<&bool> {
		self.dev_mode.as_ref()
	}

	pub fn reset_dev_mode(&mut self) {
		self.dev_mode = None;
	}

	pub fn set_access_token_type(&mut self, access_token_type: models::V1OidcTokenType) {
		self.access_token_type = Some(access_token_type);
	}

	pub fn with_access_token_type(
		mut self,
		access_token_type: models::V1OidcTokenType,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.access_token_type = Some(access_token_type);
		self
	}

	pub fn access_token_type(&self) -> Option<&models::V1OidcTokenType> {
		self.access_token_type.as_ref()
	}

	pub fn reset_access_token_type(&mut self) {
		self.access_token_type = None;
	}

	pub fn set_access_token_role_assertion(&mut self, access_token_role_assertion: bool) {
		self.access_token_role_assertion = Some(access_token_role_assertion);
	}

	pub fn with_access_token_role_assertion(
		mut self,
		access_token_role_assertion: bool,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.access_token_role_assertion = Some(access_token_role_assertion);
		self
	}

	pub fn access_token_role_assertion(&self) -> Option<&bool> {
		self.access_token_role_assertion.as_ref()
	}

	pub fn reset_access_token_role_assertion(&mut self) {
		self.access_token_role_assertion = None;
	}

	pub fn set_id_token_role_assertion(&mut self, id_token_role_assertion: bool) {
		self.id_token_role_assertion = Some(id_token_role_assertion);
	}

	pub fn with_id_token_role_assertion(
		mut self,
		id_token_role_assertion: bool,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.id_token_role_assertion = Some(id_token_role_assertion);
		self
	}

	pub fn id_token_role_assertion(&self) -> Option<&bool> {
		self.id_token_role_assertion.as_ref()
	}

	pub fn reset_id_token_role_assertion(&mut self) {
		self.id_token_role_assertion = None;
	}

	pub fn set_id_token_userinfo_assertion(&mut self, id_token_userinfo_assertion: bool) {
		self.id_token_userinfo_assertion = Some(id_token_userinfo_assertion);
	}

	pub fn with_id_token_userinfo_assertion(
		mut self,
		id_token_userinfo_assertion: bool,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.id_token_userinfo_assertion = Some(id_token_userinfo_assertion);
		self
	}

	pub fn id_token_userinfo_assertion(&self) -> Option<&bool> {
		self.id_token_userinfo_assertion.as_ref()
	}

	pub fn reset_id_token_userinfo_assertion(&mut self) {
		self.id_token_userinfo_assertion = None;
	}

	pub fn set_clock_skew(&mut self, clock_skew: String) {
		self.clock_skew = Some(clock_skew);
	}

	pub fn with_clock_skew(
		mut self,
		clock_skew: String,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.clock_skew = Some(clock_skew);
		self
	}

	pub fn clock_skew(&self) -> Option<&String> {
		self.clock_skew.as_ref()
	}

	pub fn reset_clock_skew(&mut self) {
		self.clock_skew = None;
	}

	pub fn set_additional_origins(&mut self, additional_origins: Vec<String>) {
		self.additional_origins = Some(additional_origins);
	}

	pub fn with_additional_origins(
		mut self,
		additional_origins: Vec<String>,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.additional_origins = Some(additional_origins);
		self
	}

	pub fn additional_origins(&self) -> Option<&Vec<String>> {
		self.additional_origins.as_ref()
	}

	pub fn reset_additional_origins(&mut self) {
		self.additional_origins = None;
	}

	pub fn set_skip_native_app_success_page(&mut self, skip_native_app_success_page: bool) {
		self.skip_native_app_success_page = Some(skip_native_app_success_page);
	}

	pub fn with_skip_native_app_success_page(
		mut self,
		skip_native_app_success_page: bool,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.skip_native_app_success_page = Some(skip_native_app_success_page);
		self
	}

	pub fn skip_native_app_success_page(&self) -> Option<&bool> {
		self.skip_native_app_success_page.as_ref()
	}

	pub fn reset_skip_native_app_success_page(&mut self) {
		self.skip_native_app_success_page = None;
	}

	pub fn set_back_channel_logout_uri(&mut self, back_channel_logout_uri: String) {
		self.back_channel_logout_uri = Some(back_channel_logout_uri);
	}

	pub fn with_back_channel_logout_uri(
		mut self,
		back_channel_logout_uri: String,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.back_channel_logout_uri = Some(back_channel_logout_uri);
		self
	}

	pub fn back_channel_logout_uri(&self) -> Option<&String> {
		self.back_channel_logout_uri.as_ref()
	}

	pub fn reset_back_channel_logout_uri(&mut self) {
		self.back_channel_logout_uri = None;
	}

	pub fn set_login_version(&mut self, login_version: models::V1LoginVersion) {
		self.login_version = Some(login_version);
	}

	pub fn with_login_version(
		mut self,
		login_version: models::V1LoginVersion,
	) -> ManagementServiceUpdateOidcAppConfigBody {
		self.login_version = Some(login_version);
		self
	}

	pub fn login_version(&self) -> Option<&models::V1LoginVersion> {
		self.login_version.as_ref()
	}

	pub fn reset_login_version(&mut self) {
		self.login_version = None;
	}
}
