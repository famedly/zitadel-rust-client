/*
 * User Service
 *
 * This API is intended to manage users in a ZITADEL instance.
 *
 * OpenAPI spec version: 2.0
 * Contact: hi@zitadel.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use serde_json::Value;

use crate::users::models;

#[derive(Debug, Serialize, Deserialize)]
pub struct HumanUser {
	/// Unique identifier of the user.
	#[serde(rename = "userId")]
	user_id: Option<String>,
	/// current state of the user
	#[serde(rename = "state")]
	state: Option<models::UserState>,
	/// Username of the user, which can be globally unique or unique on
	/// organization level.
	#[serde(rename = "username")]
	username: Option<String>,
	/// Possible usable login names for the user.
	#[serde(rename = "loginNames")]
	login_names: Option<Vec<String>>,
	/// Preferred login name of the user.
	#[serde(rename = "preferredLoginName")]
	preferred_login_name: Option<String>,
	/// Profile information of the user.
	#[serde(rename = "profile")]
	profile: Option<models::HumanProfile>,
	/// Email of the user, if defined.
	#[serde(rename = "email")]
	email: Option<models::HumanEmail>,
	/// Phone of the user, if defined.
	#[serde(rename = "phone")]
	phone: Option<models::HumanPhone>,
	/// User is required to change the used password on the next login.
	#[serde(rename = "passwordChangeRequired")]
	password_change_required: Option<bool>,
	/// The time the user last changed their password.
	#[serde(rename = "passwordChanged")]
	password_changed: Option<String>,
}

impl HumanUser {
	pub fn new() -> HumanUser {
		HumanUser {
			user_id: None,
			state: None,
			username: None,
			login_names: None,
			preferred_login_name: None,
			profile: None,
			email: None,
			phone: None,
			password_change_required: None,
			password_changed: None,
		}
	}

	pub fn set_user_id(&mut self, user_id: String) {
		self.user_id = Some(user_id);
	}

	pub fn with_user_id(mut self, user_id: String) -> HumanUser {
		self.user_id = Some(user_id);
		self
	}

	pub fn user_id(&self) -> Option<&String> {
		self.user_id.as_ref()
	}

	pub fn reset_user_id(&mut self) {
		self.user_id = None;
	}

	pub fn set_state(&mut self, state: models::UserState) {
		self.state = Some(state);
	}

	pub fn with_state(mut self, state: models::UserState) -> HumanUser {
		self.state = Some(state);
		self
	}

	pub fn state(&self) -> Option<&models::UserState> {
		self.state.as_ref()
	}

	pub fn reset_state(&mut self) {
		self.state = None;
	}

	pub fn set_username(&mut self, username: String) {
		self.username = Some(username);
	}

	pub fn with_username(mut self, username: String) -> HumanUser {
		self.username = Some(username);
		self
	}

	pub fn username(&self) -> Option<&String> {
		self.username.as_ref()
	}

	pub fn reset_username(&mut self) {
		self.username = None;
	}

	pub fn set_login_names(&mut self, login_names: Vec<String>) {
		self.login_names = Some(login_names);
	}

	pub fn with_login_names(mut self, login_names: Vec<String>) -> HumanUser {
		self.login_names = Some(login_names);
		self
	}

	pub fn login_names(&self) -> Option<&Vec<String>> {
		self.login_names.as_ref()
	}

	pub fn reset_login_names(&mut self) {
		self.login_names = None;
	}

	pub fn set_preferred_login_name(&mut self, preferred_login_name: String) {
		self.preferred_login_name = Some(preferred_login_name);
	}

	pub fn with_preferred_login_name(mut self, preferred_login_name: String) -> HumanUser {
		self.preferred_login_name = Some(preferred_login_name);
		self
	}

	pub fn preferred_login_name(&self) -> Option<&String> {
		self.preferred_login_name.as_ref()
	}

	pub fn reset_preferred_login_name(&mut self) {
		self.preferred_login_name = None;
	}

	pub fn set_profile(&mut self, profile: models::HumanProfile) {
		self.profile = Some(profile);
	}

	pub fn with_profile(mut self, profile: models::HumanProfile) -> HumanUser {
		self.profile = Some(profile);
		self
	}

	pub fn profile(&self) -> Option<&models::HumanProfile> {
		self.profile.as_ref()
	}

	pub fn reset_profile(&mut self) {
		self.profile = None;
	}

	pub fn set_email(&mut self, email: models::HumanEmail) {
		self.email = Some(email);
	}

	pub fn with_email(mut self, email: models::HumanEmail) -> HumanUser {
		self.email = Some(email);
		self
	}

	pub fn email(&self) -> Option<&models::HumanEmail> {
		self.email.as_ref()
	}

	pub fn reset_email(&mut self) {
		self.email = None;
	}

	pub fn set_phone(&mut self, phone: models::HumanPhone) {
		self.phone = Some(phone);
	}

	pub fn with_phone(mut self, phone: models::HumanPhone) -> HumanUser {
		self.phone = Some(phone);
		self
	}

	pub fn phone(&self) -> Option<&models::HumanPhone> {
		self.phone.as_ref()
	}

	pub fn reset_phone(&mut self) {
		self.phone = None;
	}

	pub fn set_password_change_required(&mut self, password_change_required: bool) {
		self.password_change_required = Some(password_change_required);
	}

	pub fn with_password_change_required(mut self, password_change_required: bool) -> HumanUser {
		self.password_change_required = Some(password_change_required);
		self
	}

	pub fn password_change_required(&self) -> Option<&bool> {
		self.password_change_required.as_ref()
	}

	pub fn reset_password_change_required(&mut self) {
		self.password_change_required = None;
	}

	pub fn set_password_changed(&mut self, password_changed: String) {
		self.password_changed = Some(password_changed);
	}

	pub fn with_password_changed(mut self, password_changed: String) -> HumanUser {
		self.password_changed = Some(password_changed);
		self
	}

	pub fn password_changed(&self) -> Option<&String> {
		self.password_changed.as_ref()
	}

	pub fn reset_password_changed(&mut self) {
		self.password_changed = None;
	}
}
